# MyShop 데이터베이스 설계서

## 📋 개요

### 데이터베이스 정보
- **주 DBMS**: MS SQL Server 2016+
- **향후 확장**: MySQL 5.7+ (호환 고려)
- **문자셋**: NVARCHAR 사용 (유니코드 지원)
- **Collation**: Korean_Winsock_CI_AS

---

## 🗂️ ERD (Entity Relationship Diagram)

```
┌─────────────────┐
│     users       │
│   (사용자)      │
└────────┬────────┘
         │ 1
         │
         │ N
┌────────┴────────┐
│   customers     │
│  (거래처)       │
└────────┬────────┘
         │ 1
         │
         │ N
┌────────┴────────┐         ┌─────────────────┐
│  transactions   │ N     1 │    products     │
│   (거래내역)    ├─────────┤     (상품)      │
└────────┬────────┘         └─────────────────┘
         │ 1
         │
         │ N
         │
┌────────┴────────┐
│transaction_items│
│ (거래 상세)     │
└─────────────────┘
```

---

## 📊 테이블 구조

### 1. users (사용자)

시스템 사용자 정보 및 로그인 관리

| 컬럼명 | 데이터타입 | 제약조건 | 설명 |
|--------|-----------|---------|------|
| user_code | CHAR(3) | PK | 사용자코드 (3자리 숫자) |
| user_name | NVARCHAR(50) | NOT NULL | 사용자이름 |
| mobile | VARCHAR(20) | NULL | 이동전화번호 |
| email | VARCHAR(100) | NULL | 이메일주소 |
| password | VARCHAR(255) | NOT NULL | 비밀번호 (해시) |
| is_active | BIT | DEFAULT 1 | 활성화 여부 (1:활성, 0:비활성) |
| last_login | DATETIME | NULL | 마지막 로그인 일시 |
| created_at | DATETIME | DEFAULT GETDATE() | 등록일시 |

**인덱스**
- PRIMARY KEY: user_code
- INDEX: user_name
- INDEX: email

**비즈니스 규칙**
- user_code는 3자리 숫자만 허용 (예: 001, 999)
- password는 해시화하여 저장 (PHP password_hash 사용)
- is_active가 0이면 로그인 불가
- 관리자가 DB에서 직접 사용자 추가/수정/삭제

**코드 자동생성 로직**
```sql
-- 다음 사용 가능한 코드 조회
SELECT RIGHT('000' + CAST(ISNULL(MAX(CAST(user_code AS INT)), 0) + 1 AS VARCHAR), 3)
FROM users;
```

### 2. customers (거래처)

거래처 정보를 관리하는 마스터 테이블 (세금계산서 발행 정보 포함)

| 컬럼명 | 데이터타입 | 제약조건 | 설명 |
|--------|-----------|---------|------|
| customer_code | CHAR(4) | PK | 거래처코드 (4자리 숫자, 자동생성) |
| customer_name | NVARCHAR(100) | NOT NULL | 거래처명(상호) |
| ceo_name | NVARCHAR(50) | NULL | 대표자명 |
| business_number | VARCHAR(12) | NULL | 사업자등록번호 (000-00-00000) |
| business_type | NVARCHAR(50) | NULL | 업태 (제조업, 도소매업 등) |
| business_item | NVARCHAR(50) | NULL | 종목 (전자제품, 의류 등) |
| address | NVARCHAR(255) | NULL | 사업장 주소 |
| phone | VARCHAR(20) | NULL | 전화번호 |
| fax | VARCHAR(20) | NULL | 팩스번호 |
| mobile | VARCHAR(20) | NULL | 이동전화번호 |
| email | VARCHAR(100) | NULL | 이메일 |
| manager_name | NVARCHAR(50) | NULL | 담당자명 |
| manager_contact | VARCHAR(20) | NULL | 담당자 연락처 |
| notes | NVARCHAR(MAX) | NULL | 비고 |
| created_at | DATETIME | DEFAULT GETDATE() | 등록일시 |
| updated_at | DATETIME | DEFAULT GETDATE() | 수정일시 |

**인덱스**
- PRIMARY KEY: customer_code
- INDEX: customer_name
- INDEX: business_number
- INDEX: ceo_name

**비즈니스 규칙**
- customer_code는 4자리 숫자만 허용 (예: 0001, 1234)
- 신규 등록 시 자동 생성 (현재 최대값 + 1)
- 사용자가 직접 수정 가능하며, 수정 시 중복 체크 필수 (AJAX 실시간 검증)
- customer_name은 필수 입력
- 입고처/판매처 구분 없음 (통합 관리)
- business_number는 세금계산서 발행 시 필수
- email은 전자세금계산서 발행 시 필수

**코드 자동생성 로직**
```sql
-- 다음 사용 가능한 코드 조회
SELECT RIGHT('0000' + CAST(ISNULL(MAX(CAST(customer_code AS INT)), 0) + 1 AS VARCHAR), 4)
FROM customers;
```

**코드 중복 체크 로직**
```sql
-- 실시간 중복 체크 (AJAX)
SELECT COUNT(*) FROM customers WHERE customer_code = ?;
-- 결과가 0이면 사용 가능, 1 이상이면 중복
```

---

### 3. products (상품)

상품 정보를 관리하는 마스터 테이블

| 컬럼명 | 데이터타입 | 제약조건 | 설명 |
|--------|-----------|---------|------|
| product_code | CHAR(4) | PK | 상품코드 (4자리 숫자, 자동생성) |
| product_name | NVARCHAR(100) | NOT NULL | 상품명 |
| product_spec | NVARCHAR(100) | NULL | 상품규격 |
| description | NVARCHAR(MAX) | NULL | 상품설명 |
| image_url | VARCHAR(500) | NULL | 상품이미지URL |
| info_url | VARCHAR(500) | NULL | 상품안내페이지URL |
| notes | NVARCHAR(MAX) | NULL | 비고 |
| stock_quantity | INT | DEFAULT 0 | 현재 재고수량 (음수 허용) |
| standard_price | DECIMAL(15,2) | DEFAULT 0 | 기준 단가 |
| created_at | DATETIME | DEFAULT GETDATE() | 등록일시 |
| updated_at | DATETIME | DEFAULT GETDATE() | 수정일시 |

**인덱스**
- PRIMARY KEY: product_code
- INDEX: product_name

**비즈니스 규칙**
- product_code는 4자리 숫자만 허용 (예: 0001, 9999)
- 신규 등록 시 자동 생성 (현재 최대값 + 1)
- 사용자가 직접 수정 가능하며, 수정 시 중복 체크 필수 (AJAX 실시간 검증)
- product_name은 필수 입력
- **stock_quantity는 음수 허용 (마이너스 재고 가능)**
- 입출고 시 자동 증감
- **image_url은 외부 이미지 URL 저장 (파일 업로드 없음)**
- image_url 입력 시 JavaScript로 미리보기 제공

**코드 자동생성 로직**
```sql
-- 다음 사용 가능한 코드 조회
SELECT RIGHT('0000' + CAST(ISNULL(MAX(CAST(product_code AS INT)), 0) + 1 AS VARCHAR), 4)
FROM products;
```

**코드 중복 체크 로직**
```sql
-- 실시간 중복 체크 (AJAX)
SELECT COUNT(*) FROM products WHERE product_code = ?;
-- 결과가 0이면 사용 가능, 1 이상이면 중복
```

---

### 4. transactions (거래내역)

입출고, 반품, 수금, 지급 등 모든 거래의 헤더 정보

| 컬럼명 | 데이터타입 | 제약조건 | 설명 |
|--------|-----------|---------|------|
| transaction_id | INT | PK, IDENTITY(1,1) | 거래 ID |
| transaction_date | DATE | NOT NULL | 거래일자 |
| transaction_type | VARCHAR(20) | NOT NULL | 거래유형 |
| customer_code | CHAR(4) | FK, NOT NULL | 거래처코드 |
| user_code | CHAR(3) | FK, NOT NULL | 입력 사용자코드 |
| total_amount | DECIMAL(15,2) | DEFAULT 0 | 총 거래금액 |
| notes | NVARCHAR(MAX) | NULL | 비고 |
| created_at | DATETIME | DEFAULT GETDATE() | 등록일시 |
| updated_at | DATETIME | DEFAULT GETDATE() | 수정일시 |

**거래유형 (transaction_type) 값**
- `IN`: 입고
- `OUT`: 출고
- `IN_RETURN`: 입고반품
- `OUT_RETURN`: 출고반품
- `RECEIVE`: 수금
- `PAYMENT`: 지급

**인덱스**
- PRIMARY KEY: transaction_id
- INDEX: transaction_date
- INDEX: customer_code
- INDEX: user_code
- INDEX: transaction_type
- FOREIGN KEY: customer_code → customers(customer_code)
- FOREIGN KEY: user_code → users(user_code)

**비즈니스 규칙**
- transaction_date는 과거 또는 당일만 허용
- user_code는 로그인한 사용자 정보로 자동 입력
- 수금/지급은 transaction_items 없이 헤더만 존재
- total_amount는 transaction_items의 합계와 일치해야 함

**MySQL 호환 참고사항**
```sql
-- MSSQL: IDENTITY(1,1)
-- MySQL: AUTO_INCREMENT

-- MSSQL: GETDATE()
-- MySQL: CURRENT_TIMESTAMP

-- MSSQL: NVARCHAR(MAX)
-- MySQL: TEXT
```

---

### 4. transaction_items (거래 상세)

입출고, 반품 거래의 상품별 상세 내역

| 컬럼명 | 데이터타입 | 제약조건 | 설명 |
|--------|-----------|---------|------|
| item_id | INT | PK, IDENTITY(1,1) | 상세 ID |
| transaction_id | INT | FK, NOT NULL | 거래 ID |
| product_code | CHAR(4) | FK, NOT NULL | 상품코드 |
| quantity | INT | NOT NULL | 수량 |
| unit_price | DECIMAL(15,2) | NOT NULL | 단가 |
| amount | DECIMAL(15,2) | NOT NULL | 금액 (수량 × 단가) |
| created_at | DATETIME | DEFAULT GETDATE() | 등록일시 |

**인덱스**
- PRIMARY KEY: item_id
- INDEX: transaction_id
- INDEX: product_code
- FOREIGN KEY: transaction_id → transactions(transaction_id) ON DELETE CASCADE
- FOREIGN KEY: product_code → products(product_code)

**비즈니스 규칙**
- quantity는 양수만 허용
- amount = quantity × unit_price (기본값)
- amount를 수정하면 unit_price = amount / quantity로 재계산
- 입고/입고반품은 quantity > 0
- 출고/출고반품도 quantity > 0 (방향은 transaction_type으로 구분)

**MySQL 호환 참고사항**
```sql
-- MSSQL: IDENTITY(1,1)
-- MySQL: AUTO_INCREMENT

-- MSSQL: GETDATE()
-- MySQL: CURRENT_TIMESTAMP
```

---

## 🔗 테이블 관계

### 1:N 관계

1. **users (1) : transactions (N)**
   - 한 사용자는 여러 거래를 입력할 수 있음
   - 외래키: transactions.user_code → users.user_code

2. **customers (1) : transactions (N)**
   - 한 거래처는 여러 거래내역을 가질 수 있음
   - 외래키: transactions.customer_code → customers.customer_code

3. **transactions (1) : transaction_items (N)**
   - 한 거래는 여러 상품 항목을 가질 수 있음
   - 외래키: transaction_items.transaction_id → transactions.transaction_id
   - CASCADE DELETE: 거래 삭제 시 상세 항목도 함께 삭제

4. **products (1) : transaction_items (N)**
   - 한 상품은 여러 거래 항목에 포함될 수 있음
   - 외래키: transaction_items.product_code → products.product_code

---

## 🔍 주요 쿼리 패턴

### 1. 거래처별 거래내역 조회 (입력자 포함)
```sql
-- MSSQL
SELECT 
    t.transaction_date,
    t.transaction_type,
    c.customer_name,
    p.product_name,
    ti.quantity,
    ti.unit_price,
    ti.amount,
    u.user_name AS input_user,
    t.created_at AS input_datetime
FROM transactions t
INNER JOIN customers c ON t.customer_code = c.customer_code
INNER JOIN users u ON t.user_code = u.user_code
LEFT JOIN transaction_items ti ON t.transaction_id = ti.transaction_id
LEFT JOIN products p ON ti.product_code = p.product_code
WHERE t.transaction_date BETWEEN @start_date AND @end_date
  AND (t.customer_code = @customer_code OR @customer_code = 'ALL')
ORDER BY t.transaction_date DESC, t.transaction_id DESC;
```

### 2. 상품 재고 조회
```sql
SELECT 
    product_code,
    product_name,
    stock_quantity,
    standard_price,
    (stock_quantity * standard_price) AS stock_value
FROM products
WHERE stock_quantity > 0
ORDER BY product_name;
```

### 3. 입고 처리 (재고 증가, 음수 허용)
```sql
-- MSSQL
BEGIN TRANSACTION;

-- 1. 거래 헤더 등록 (로그인한 사용자 정보 포함)
INSERT INTO transactions (transaction_date, transaction_type, customer_code, user_code, total_amount)
VALUES (@trans_date, 'IN', @customer_code, @user_code, @total_amount);

DECLARE @transaction_id INT = SCOPE_IDENTITY();

-- 2. 거래 상세 등록
INSERT INTO transaction_items (transaction_id, product_code, quantity, unit_price, amount)
VALUES (@transaction_id, @product_code, @quantity, @unit_price, @amount);

-- 3. 재고 증가 (음수 허용, CHECK 제약 없음)
UPDATE products 
SET stock_quantity = stock_quantity + @quantity
WHERE product_code = @product_code;

COMMIT TRANSACTION;
```

### 4. 출고 처리 (재고 감소, 음수 허용)
```sql
-- MSSQL
BEGIN TRANSACTION;

-- 재고 부족 체크 제거 (음수 허용)

-- 1. 거래 헤더 등록 (로그인한 사용자 정보 포함)
INSERT INTO transactions (transaction_date, transaction_type, customer_code, user_code, total_amount)
VALUES (@trans_date, 'OUT', @customer_code, @user_code, @total_amount);

DECLARE @transaction_id INT = SCOPE_IDENTITY();

-- 2. 거래 상세 등록
INSERT INTO transaction_items (transaction_id, product_code, quantity, unit_price, amount)
VALUES (@transaction_id, @product_code, @quantity, @unit_price, @amount);

-- 3. 재고 감소 (음수 허용)
UPDATE products 
SET stock_quantity = stock_quantity - @quantity
WHERE product_code = @product_code;

COMMIT TRANSACTION;
```

---

## 🛡️ 데이터 무결성 규칙

### 제약 조건

1. **사용자코드 형식**
   ```sql
   -- MSSQL
   CHECK (user_code LIKE '[0-9][0-9][0-9]')
   ```

2. **거래처코드 형식**
   ```sql
   -- MSSQL
   CHECK (customer_code LIKE '[0-9][0-9][0-9][0-9]')
   ```

3. **상품코드 형식**
   ```sql
   -- MSSQL
   CHECK (product_code LIKE '[0-9][0-9][0-9][0-9]')
   ```

4. **수량 양수**
   ```sql
   CHECK (quantity > 0)
   ```

5. **재고 음수 허용**
   ```sql
   -- CHECK 제약조건 없음 (음수 재고 허용)
   -- stock_quantity INT (음수 가능)
   ```

### 트리거

#### 1. 입고 시 재고 자동 증가
```sql
DELIMITER //
CREATE TRIGGER trg_stock_in
AFTER INSERT ON transaction_items
FOR EACH ROW
BEGIN
    IF EXISTS (
        SELECT 1 FROM transactions 
        WHERE transaction_id = NEW.transaction_id 
        AND transaction_type IN ('IN', 'OUT_RETURN')
    ) THEN
        UPDATE products 
        SET stock_quantity = stock_quantity + NEW.quantity
        WHERE product_code = NEW.product_code;
    END IF;
END//
DELIMITER ;
```

#### 2. 출고 시 재고 자동 감소
```sql
DELIMITER //
CREATE TRIGGER trg_stock_out
AFTER INSERT ON transaction_items
FOR EACH ROW
BEGIN
    IF EXISTS (
        SELECT 1 FROM transactions 
        WHERE transaction_id = NEW.transaction_id 
        AND transaction_type IN ('OUT', 'IN_RETURN')
    ) THEN
        UPDATE products 
        SET stock_quantity = stock_quantity - NEW.quantity
        WHERE product_code = NEW.product_code;
    END IF;
END//
DELIMITER ;
```

#### 3. 거래 삭제 시 재고 복원
```sql
DELIMITER //
CREATE TRIGGER trg_stock_restore
BEFORE DELETE ON transaction_items
FOR EACH ROW
BEGIN
    DECLARE v_type VARCHAR(20);
    
    SELECT transaction_type INTO v_type
    FROM transactions
    WHERE transaction_id = OLD.transaction_id;
    
    IF v_type IN ('IN', 'OUT_RETURN') THEN
        UPDATE products 
        SET stock_quantity = stock_quantity - OLD.quantity
        WHERE product_code = OLD.product_code;
    ELSEIF v_type IN ('OUT', 'IN_RETURN') THEN
        UPDATE products 
        SET stock_quantity = stock_quantity + OLD.quantity
        WHERE product_code = OLD.product_code;
    END IF;
END//
DELIMITER ;
```

---

## 📈 확장 고려사항

### 향후 추가 가능한 테이블

1. ~~**users** - 사용자 관리~~ ✅ 추가 완료
2. **categories** - 상품 분류
3. **inventory_logs** - 재고 변동 상세 이력
4. **account_balances** - 거래처별 미수금/미지급금
5. **settings** - 시스템 설정
6. **user_roles** - 사용자 권한 관리 (향후 확장)

---

## 🔐 보안 고려사항

1. **사용자 로그인**
   - 비밀번호는 PHP password_hash() 함수로 해시화
   - 세션 관리로 로그인 상태 유지
   - 로그인하지 않으면 시스템 접근 불가

2. **SQL Injection 방어**
   - Prepared Statement 사용 필수
   - 사용자 입력값 검증

3. **XSS 방어**
   - 외부 URL 입력 시 검증
   - 이미지 URL은 <img> 태그로 표시 시 htmlspecialchars 사용

4. **백업**
   - 일일 자동 백업 권장
   - 주요 거래 전 수동 백업

5. **사용자 관리**
   - 관리자가 DB에서 직접 관리
   - users 테이블 직접 INSERT/UPDATE
   - 비밀번호 변경 시 해시화 필수

---

## 📝 데이터베이스 생성 스크립트

다음 단계에서 실제 SQL 스크립트를 제공합니다.

---

## 버전 정보
- **버전**: 1.0
- **작성일**: 2025년 10월 13일
- **최종 수정일**: 2025년 10월 13일